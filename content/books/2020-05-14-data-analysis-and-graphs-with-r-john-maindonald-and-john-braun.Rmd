---
title: "Data Analysis and Graphs with R by J.Maindonald and J.Braun"
date: 2020-05-14
output:
  html_document:
    fig_width: 8.5
    fig_height: 4
---

```{r,echo=F,include=F,warning=F,message=F}
library(tidyverse)
library(DAAG)
library(Amelia)
library(patchwork)

theme_graph <- function(){
  theme(
    plot.title = element_text(size = 16),
    plot.subtitle = element_text(size = 12),
    plot.caption = element_text(face = "italic", size = 9),
    axis.text = element_text(size = 9),
    axis.title = element_text(face = "italic", size = 9),
    text = element_text(family = "Times New Roman"),
    strip.background = element_rect(fill = "grey"),
    strip.text = element_text(face = "bold"),
    legend.title = element_blank(),
    legend.position = "bottom"
  )
}
```

## **Overview**

This book is part of a project made by Cambrige University called **Cambridge Series in Statistics and Probabilistic Mathematics** aiming to spread knowledge in statistics. As well as this book, there're other 19 that explore other areas of statistics.

The content of this book is more generic, where the authors explain a range of concepts, from exploratory data analysis, statistical tests, tree models and survival analysis. The book was published in 2006 (the second edition) and I think because of that the authors didn't use libraries like ggplot or the tidyverse universe.

The explanations given by the authors are clear and easy to understand, also the utilization of data sets from R packages (e.g. DAAG) simplify reproducibility of examples and execution of models to solve the proposed exercises.

![Book cover](/images/2020-02-07_data_analysis_with_r.png)

## **Chapter 1 - A brief introduction to R**

In this chapter the focus is to introduce the R enviroment to the reader. With this goal, the authors explain the types of data that R can handle, how to build functions and what kind of graphs are possible with this tool. Let's see some exercises presented this chapter.

### **Exercises**

### **1. The following table gives the size of the floor area (ha) and the price ($A000), for 15 houses sold in the Canberra (Australia) suburb of Aranda in 1999.**

```{r, message = F, warning = F}
df <- data.frame(area = c(694,905,802,1366,716,963,821,714,1018,887,790,696,771,1006,1191),
                 sale.price = c(192,215,215,274,112.7,185,212,220,276,260,221,255,260,293,375))
```

### **a) Plot sale.price versus area.**

**A:** For this, I'll use ggplot library instead of base R plots, because it's easier and prettier.

```{r, message = F, warning = F}
df %>% 
  ggplot2::ggplot()+
  geom_point(mapping = aes(x = area, y = sale.price), 
             color = "darkred")+
  theme_graph()+
  labs(title = "Sales Price vs Area")
```

### **b) Use hist() command to plot a histogram of the sales.price.**

**A:** In this alternative I won't use the hist() command. Instead I'll opt for the geom_histogram from ggplot.

```{r, message = F, warning = F}
df %>% 
  ggplot2::ggplot()+
  geom_histogram(mapping = aes(x = sale.price),
                 fill = "darkblue",
                 alpha = .4)+
  theme_graph()+
  labs(title = "Sales Price Histogram")
```

### **c) Repeat (a) and (b) after taking logarithms of sale prices.**

**A:** It's possible to reproduce the same graphs and put the log() formula on the variables inside aes() function.

```{r, message = F, warning = F}
df %>% 
  ggplot2::ggplot()+
  geom_point(mapping = aes(x = log(area), y = log(sale.price)),
             color = "darkred")+
  theme_graph()+
  labs(title = "Sales Price vs Area using log transformation")
```

The histogram will follow the same logic.

```{r, message = F, warning = F}
df %>% 
  ggplot2::ggplot()+
  geom_histogram(mapping = aes(x = log(sale.price)),
                 fill = "darkblue",
                 alpha = .4)+
  theme_graph()+
  labs(title = "Sale Price Histograma",
       subtitle = "Log transformed")
```

## **Chapter 2 - Styles of data analysis**

This chapter explains about exploratory data analysis, a technique developed by John Tukey to support researchers during their initial problem exploration. The aythors present the types of graphs available for researchers and when to use each of them. Also, they explain about outliers and data skewness, showing how to deal with each situation.

### **Exercises**

### **1) Use the lattice function bwplot() to display, for each combination of *site* and *sex* in the data frame *possum*(DAAG package), the distribution of ages. Show the different sites on the same panel, with different panels for different sexes.**

**A:** bwplot means box and whisker plot (a.k.a boxplot). It's a good visualization to present distribution among different categories. Let's create the boxplot using ggplot.

```{r, message = F, warning = F}
DAAG::possum %>%
  ggplot2::ggplot()+
  geom_boxplot(mapping = aes(y = age, group = site, fill = as.factor(site)),
               outlier.shape = 20,
               outlier.color = "black")+
  theme_graph()+
  theme(legend.title = element_text(size = 7))+
  scale_fill_viridis_d()+
  facet_grid(~sex)+
  labs(title = "Age distribution for different sites")
```

### **3) Plot a histogram of the earconch measurements for the possum data. The distribution should appear bimodal (two peaks). This is a simple indication of clustering, possibly due to sex differences. Obtain side-by-side boxplots of the male and female earconch measurements. How do these measurement distributions differ? Can you predict what the corresponding histograms would look like? Plot them to check your answer.**

**A:** If the data ser contains men and women in a similar proportion, the histogram will be bicaudal, because the measure differ for each gender.

```{r, message = F, warning = F}
DAAG::possum %>% 
  ggplot2::ggplot()+
  geom_histogram(mapping = aes(x = earconch),
                 fill = "darkred",
                 alpha = .2,
                 color = "darkred",
                 size = 1)+
  theme_graph()+
  labs(title = "Earconch Distribution")
```

Now let's see the boxblot for each gender.

```{r, message = F, warning = F}
DAAG::possum %>% 
  ggplot2::ggplot()+
  geom_boxplot(mapping = aes(y = earconch, fill = sex),
               alpha = .2)+
  scale_fill_viridis_d()+
  theme_graph()+
  labs(title = "Earconch box plot distribution",
       x = "",
       y = "")
```

## **Chapter 3 - Statistical models**

This chapter introduce the fundations of statistical models. First the authors explain the importance of statistical models, showing the difference between physical phenomenon and random events that has singnal and noise well established. 

They affirm that models have to provide accurate inferences in order to allow predictions. Thus, for researchers build reliable models it's necessary to set hypothesis about data distribution, sampling method and also assumptions about the parameters of the model.

As the assumption of the data distribution is an important part of model definition, the authors explain how to validate if the data is normally distributed, using visual displays (i.e. histograms on qq-plots) or formal tests.

### **Exercises**

### **2) Use y <- rnorm(100) to generate a random sample of 100 numbers from a normal distribution. Calculate the mean and standard deviation of y. Now put the calculation in a loop and repeat 25 times. Store the 25 means in a vector named av. Calculate the standard deviation of the values in av.**

```{r, message = F, warning = F}
y <- rnorm(100)

tibble(mean = mean(y),
           sd = sd(y))
```

**A:** In order to run this process, it's necessary to create an empty variable with 25 slots available, then create a *for lopp* that will calculate the mean for a sample of 100 values taken from a normal distribution, 25 times.

```{r, message = F, warning = F}
# Creating an empty variable with 25 slots
output <- rep(NA,25)

# Creating the for loop
for(i in 1:25){
  output[i] <- data.frame(
    mean(rnorm(100))
  )
}

# Extracting the output and inserting it in a data.frame
df <- data.frame(
  a = matrix(unlist(output),nrow = 25,byrow = F), stringsAsFactors = F)

# Calculating the mean and sd
tibble(mean = mean(df[,1]),
           sd = sd(df[,1]))
```

### **3) Create a function that does the calculations of Exercise 2. Run the function several times, showing each of the distributions of 25 means in a density plot.**

```{r, message = F, warning = F}
# Creating the function, x = repetitions, y = random samples
fun <- function(x, y){
  output <- rep(NA, x)
  for(i in 1:x){
    output[i] <- data.frame(
      round(mean(rnorm(y)), digits = 2)
    )
  }
  df <- data.frame(
    a = matrix(unlist(output), 
               nrow = x,
               byrow = T), 
    stringsAsFactors = F)
}

# Running the function and ploting the results
fun(25, 100) %>% 
  ggplot2::ggplot()+
  geom_density(mapping = aes(x = a),
               fill = "dark orange",
               alpha = .2)+
  theme_graph()+
  labs(title = "Density plot for ")
```

## **Chapter 4 - An introduction to formal inference**

This chapter introduces some basic concepts about statistical inference. The main concepts about this subject are **Standard Error of the Mean**; **student distribution**; **degress of freedom**; **p-values**; **confidence intervals**; **test of hypothesis**.

The authors explain the formulas for some of these variables, how to perform hypothesis test and build confidence intervals and also, why researchers are moving from hypothesis test to confidence intervals. 

### **Exercises**

### **1) In the data set nsw74demo (DAAG) determine 95% confidence intervals for: (a) the 1974 incomes of each of the “treated” and “control” groups; (b) the 1975 incomes of each group; (c) the 1978 incomes of each group. Finally, calculate a 95% confidence interval for the difference in income between treated and controls in 1978.**

**A:** As explained in this chapter, confidence intervals are build using the following equation:

$$\mu - (t_\frac{\alpha}{2} \times SEM)$$
Changing the signals from minus to plus in order to obtain the the upper limit instead of the lower.

Where:

$\mu$ = the sample mean given in the data set.

$t_\frac{\alpha}{2} = $ Critical t value obtained using the confidence level ($\alpha$) and dividing by two because we'll validate the two side of the distribution (bicaudal test).

$SEM = \frac{s}{\sqrt{n}}$.

$s = $ Sample standard deviation.

$n = $ Number of observations taken.


In the data set mentioned, we have one group being studied in different time and then being compared with a control group. The groups are identified by the field **trt** that will be equal 1 for treatment groups and 0 for control grups. Let's develop a data.frame that will allow us to answer all three questions.

First I'll group the data set and take the average income of each group in different columns. Then, I'll calculate the critical t value from the student distribution and with this value I'll create the standard error of the mean for each timeframe. With this values it will be possible to calculate the limits of the invervals.

```{r, message = F, warning = F}
DAAG::nsw74demo %>%
  mutate(group = ifelse(trt == 0, "control","test")) %>% 
  group_by(group) %>% 
  summarise(n = n(),
            avg_income_74 = mean(re74),
            avg_income_75 = mean(re75),
            avg_income_78 = mean(re78),
            sem_74 = sd(re74)/sqrt(n),
            sem_75 = sd(re75)/sqrt(n),
            sem_78 = sd(re78)/sqrt(n)) %>% 
  mutate(critical_t = qt(0.975, n),
         sem_74_times_critical_t = sem_74 * critical_t,
         sem_75_times_critical_t = sem_75 * critical_t,
         sem_78_times_critical_t = sem_78 * critical_t,
         inc74_lower = avg_income_74 - sem_74_times_critical_t,
         inc_74_upper = avg_income_74 + sem_74_times_critical_t,
         inc_75_lower = avg_income_75 - sem_74_times_critical_t,
         inc_75_upper = avg_income_75 + sem_74_times_critical_t,
         inc_78_lower = avg_income_78 - sem_74_times_critical_t,
         inc_78_upper = avg_income_78 + sem_74_times_critical_t) %>% 
  select(group,
         inc74_lower,
         inc_74_upper,
         inc_75_lower,
         inc_75_upper,
         inc_78_lower,
         inc_78_upper)
```

Now, the final question demand us to estimate the income difference between treated and control groups in 1978, with 95% of confidence. For this estimation, the book recommends the following equation:

$SED = \sqrt{SEM_1^2 + SEM_2^2}$

Where:

SED = *standard error of the difference*

$SEM_control$ = *standard error of the mean*

$SEM_test$ = *standard error of the mean*

$SED = \sqrt{415^2+680^2}$

$SED = \sqrt{172.225+462.400}$

$SED = 796,6$

**A:** The income difference between groups, with 95% of confidence is of 796,6.

### **2)  Draw graphs that show, for degrees of freedom between 1 and 100, the change in the 5% critical value of the t-statistic. Compare a graph on which neither axis is transformed with a graph on which the respective axis scales are proportional to log(t-statistic) and log(degrees of freedom). Which graph gives the more useful visual indication of the change in the 5% critical value of the t-statistic with increasing degrees of freedom?.**

```{r, message = F, warning = F}
t_value <- 
  data.frame(df = seq(1, 100, by = 1)) %>% 
  mutate(t_value = qt(0.975, df = row_number()))

g1 <- t_value %>% 
  ggplot2::ggplot()+
  geom_line(mapping = aes(x = df, y = t_value))+
  scale_x_log10()+
  scale_y_log10()+
  theme_graph()+
  labs(title = "Log transformation applied",
       x = "log_10 of Degrees of freedom",
       y = "log_10 of t-statistics")

g2 <- t_value %>% 
  ggplot2::ggplot()+
  geom_line(mapping = aes(x = df, y = t_value))+
  theme_graph()+
  labs(title = "Log transformation not applied",
       x = "Degrees of freedom",
       y = "t-statistics")

g1 + g2
```

### **3)  Generate a random sample of 10 numbers from a normal distribution with mean 0 and standard deviation 2. Use t.test() to test the null hypothesis that the mean is 0. Now generate a random sample of 10 numbers from a normal distribution with mean 1.5 and standard deviation 2. Again use t.test() to test the null hypothesis that the mean is 0. Finally write a function that generates a random sample of n numbers from a normal distribution with mean and standard deviation 1, and returns the p-value for the test that the mean is 0..**

**A:** This question demands us to make a hypothesis test using a random data set. Let's create this data set with using a normal distribution.

```{r, message = F, warning = F}
df <- rnorm(n = 10, mean = 0, sd = 2)

# Visualizing the data set
df
```

Now, let's make R calculate the t.test() and see the result and after this I'll calculate the p-value by hand to reach the same result. I expect that the null hypothesis ($H0: \mu = 0$) won't be rejected, because the data set was generated from a population with mean 0.

```{r, message = F, warning = F}
df %>% 
  t.test(mu = 0, conf.level = 0.975)
```

The t.test from R generated a p-value of 0.7261. In this case we can't reject H0 as expected. Now let's make the calculation step by step.

```{r, message = F, warning = F}
mean <- mean(df)
sd <- sd(df)
n_sqrt <- sqrt(length(df))

sem <- sd/n_sqrt

(1-pt(mean/sem, 10-1))*2
```

The same p-value was obtained. Thus, we can rely on our t.test() from R and understand what it is happening on backstage.

Now, the question ask us to perform the same method in a population with mean 1.5. In this case, let's make the sample generation and statistical modeling all at once.

```{r, message = F, warning = F}
data.frame(rnorm(n = 10, mean = 1.5, sd = 2)) %>% 
  t.test(mu = 0, conf.level = 0.975)
```

In this test, the p-value obtained was lower, but not sufficient to make us reject H0: $\mu = 0$. Maybe it's because the sample size is small. Let's remake the test with a larger sample.

```{r, message = F, warning = F}
data.frame(rnorm(n = 100, mean = 1.5, sd = 2)) %>% 
  t.test(mu = 0, conf.level = 0.975)
```

Now, the p-value is pretty lower and we can reject H0 with a 95% of confidence.

### **4)  Use the function that was created in Exercise 3 to generate 50 independent p-values, all with a sample size n = 10 and with mean = 0. Use qqplot(), with the parameter setting x = qunif(ppoints(50)), to compare the distribution of the p-values with that of a uniform random variable, on the interval [0, 1]. Comment on the plot.**

**A:** In the last exercise I didn't create the function, then I'll create it now. The function will generates a random sample of *n* numbers from a normal distribution with mean $\mu = 0$ and standard deviation 1, and will return the **p-value** from a test considering **H0: $\mu = 0$**.

The first thing we have to make in order to build a function, is to create an empty vector that will receive the output. Then, we create the function and fill this vector with the output from the function. Let's see how it works.

```{r, message = F, warning = F}
# Creating the empty vector
output <- rep(NA,50)

# Creating the function with the p-value
for(i in 1:50){
  sample <- rnorm(n = 10, mean = 0, sd = 1)
  mean <- mean(sample)
  sd <- sd(sample)
  sem <- sd/sqrt(10)
  output[i] <- data.frame(p_value = (1-pt((abs(mean)/sem),9))*2)
}

# Putting function output in a data.frame
df <- data.frame(a = matrix(unlist(output), 
                            nrow = 50, 
                            byrow = T))
```

Now we have the data.frame and we're ready to plot the requested qq-plot. This plot is nice to visualize how normal is the data distribution. For this case, we have a sample obtained from a population with mean 0 and sd 1 and we're testing the Null Hypothesis that population mean is 0. Then, the p-value has to by high (more than 0.05 at least) in order to preclude the rejection of H0. The qq-plot will show that p-value is normally distributed. I'll also generate a histogram to show that p-value is high in most of the cases (the data.frame contains 50 p-values). Let's see both graphs 

```{r, message = F, warning = F}
# Generating the qq-plot
g1 <- df %>% 
  ggplot2::ggplot()+
  geom_qq(mapping = aes(sample = a),
          color = "dark blue")+
  geom_qq_line(mapping = aes(sample = a),
               lty = 2,
               color = "dark orange")+
  theme_graph()+
  labs(title = "QQ plot for p-values")

# Generating the histogram
g2 <- df %>% 
  ggplot2::ggplot()+
  geom_histogram(mapping = aes(x = a),
                 fill = "dark blue",
                 alpha = .3)+
  geom_vline(xintercept = 0.05,
             lty = 2,
             color = "dark orange")+
  scale_x_continuous(labels = scales::percent)+
  theme_graph()+
  labs(title = "Histogram of p-values")

g1+g2
```

Look that most of the p-values generated are on the righ side of the histogram's yellow dached line. This indicates that most of the Null Hypothesis wouldn't be rejected considering a significance level of 5%.

### **6) Here we generate random normal numbers with a sequential dependence structure. Repeat this several times. There should be no consistent pattern in the ACF plot for different random samples y1. There will be a fairly consistent pattern in the ACF plot for y, a result of the correlation that is introduced by adding to each value the next value in the sequence.**

```{r, message = F, warning = F}
# Random numbers mentioned in the exercise
y1 <- rnorm(51)
y <- y1[-1] + y1[-51]
acf(y1) # acf is ‘autocorrelation function’
acf(y)
```

### **8) (a) For each column of the data set nsw74psid1 after the first, compare the control group (trt==0) with the treatment group (trt==1). Use overlaid density plots to compare the continuous variables, and two-way tables to compare the binary (0/1) variables. Where are the greatest differences?.**

**A:** In this exercise I'll generate box plots for continuous variables in order to compare the control and treated groups.

```{r, message = F, warning = F}
g1 <- DAAG::nsw74psid1 %>%
  mutate(trt = as.factor(trt)) %>% 
  ggplot2::ggplot()+
  geom_boxplot(mapping = aes(y = age, group = trt, color = trt),
               outlier.shape = 20,
               outlier.color = "black")+
  scale_color_brewer(type = "qual")+
  theme(axis.text.x = element_blank())+
  theme_graph()

g2 <- DAAG::nsw74psid1 %>% 
  mutate(trt = as.factor(trt)) %>% 
  ggplot2::ggplot()+
  geom_boxplot(mapping = aes(y = educ, group = trt, color = trt),
               outlier.shape = 20,
               outlier.color = "black")+
  scale_color_brewer(type = "qual")+
  theme_graph()+
  theme(axis.text.x = element_blank())

g3 <- DAAG::nsw74psid1 %>% 
  mutate(trt = as.factor(trt)) %>% 
  ggplot2::ggplot()+
  geom_boxplot(mapping = aes(y = re74, group = trt, color = trt),
               outlier.shape = 20,
               outlier.color = "black")+
  scale_y_log10(labels = scales::comma)+
  scale_color_brewer(type = "qual")+
  theme_graph()+
  theme(axis.text.x = element_blank())

g4 <- DAAG::nsw74psid1 %>% 
  mutate(trt = as.factor(trt)) %>% 
  ggplot2::ggplot()+
  geom_boxplot(mapping = aes(y = re75, group = trt, color = trt),
               outlier.shape = 20,
               outlier.color = "black")+
  scale_y_log10(labels = scales::comma)+
  scale_color_brewer(type = "qual")+
  theme_graph()+
  theme(axis.text.x = element_blank())

g5 <- DAAG::nsw74psid1 %>% 
  mutate(trt = as.factor(trt)) %>% 
  ggplot2::ggplot()+
  geom_boxplot(mapping = aes(y = re78, group = trt, color = trt),
               outlier.shape = 20,
               outlier.color = "black")+
  scale_y_log10(labels = scales::comma)+
  scale_color_brewer(type = "qual")+
  theme_graph()+
  theme(axis.text.x = element_blank())

# Putting all graphs together
plots <- (g1+g2)/(g3|g4|g5)

plots +
  plot_layout(guides = "collect")+
  plot_annotation(title = "Continuous variables comparison",
                  subtitle = "Control (0) and treated (1) groups")
```

