---
title: "Treinamento de R e Rmarkdown"
author: "Francisco Piccolo"
date: "2020-05-28"
output:
  html_document:
    df_print: paged
    highlight: zenburn
    fig_width: 7
    fig_height: 3.5
    css: style.css
---
  
## **Introdução**

Neste treinamento, irei apresentar como eu desenvolvo pesquisas e análise de dados na Dafiti, utilizando R markdown e conectando o R ao Redshift. Para coneguir aproveitar o conteúdo deste treinamento, é importante você ter familiaridade com a sintax markdown, possuir R / Rstudio instalado em sua máquina e familiaridade com SQL. Neste [link](https://www.markdownguide.org/basic-syntax/) há alguns operadores básicos de Rmarkdown.

O conteúdo deste treinamento está subdividido da seguinte forma:

* Entendendo o R e Rstudio

* Principais pacotes usados em pesquisa (80/20 rule)

* Entendendo documentos Rmarkdown

* Conectando o R ao Redshift

* Desenvolvendo pesquisas

* Inserindo pesquisas na página da Dafiti

Vou tentar inserir materiais de apoio ao final de cada tópico, com leituras adicionais para quem quiser se aprofundar no tema.

## **Entendendo o R e Rstudio**

R é basicamente uma linguagem de programação e um software estatístico. Foi criado como um upgrade da linguagem S, que foi criada por John Tukey, um dos idealizadores da análise de dados (formal).

O R funciona basicamente como uma calculadora, onde você pode inserir operadores matemáticos e rodar o código através do *ctrl + enter*. Por exemplo:

```{r}
10 + 2
```

Pode-se também criar variáveis através do comando *alt + -* que irá criar um **"<-"**. Como o R é uma linguagem "vetorizada", ao criar um vetor e aplicar uma operação nele, o R irá fazer esta operação para todos os elementos do vetor. Um vetor pode ser criado usando **c()** e inserindo os elementos do vetor dentro dos parenteses.

```{r}
var_1 <- c(1,2,3,4,5)

# Realizando operações na variável / vetor

2*var_1

# Variável contendo raiz quadrada da variável 1
var_2 <- sqrt(var_1)
```

Chamando uma variável:

```{r}
var_2
```

Importante notar, que eu estou no **Global Enviroment**. Eu prefiro usar este enviroment, pois não uso pacotes que possam entrar em conflito e não realizo projetos muito complexos, desta forma, todas as variáveis são criadas no global enviroment e, ao iniciar um novo projeto de pesquisa, eu faço a limpeza do meu *enviroment* através dos comandos:

```{r}
rm(list = ls())
```

A função **rm** remove os objetos de uma sessão ou *enviroment* e por ser uma função, ela precisa de parâmetros. Um deles é o **list**, que conterá as variáveis a serem removidas. Dentro desta lista, eu posso colocar um vetor de variáveis para serem removidas. Como eu removo tudo, eu uso a função **ls()**, que lista todos os objetos ou variáveis do meu *enviroment*.

Mas como saber que esta função faz isso? No R, caso você tenha um problema e não saiba como resolvê-lo, a comunidade será sua melhor parceira. Atualmente, minhas duas fontes para tirar dúvidas são:

* Grupo R Brasil do Telegram (https://t.me/rbrasiloficial)

* [Stack Overflow](https://stackoverflow.com/questions/2615128/where-does-r-store-packages)

Outro cenário, que exige outro tipo de solução, é quando você sabe que uma função pode ser usada para um dado problema, porém não se lembra como usá-la. Nesta caso, o próprio R pode ser sua primeira opção. Usando o comando help, o R irá lhe trazer a documentação do pacote ou função em questão. Há duas formas de se pedir ajuda no R.

```{r, eval=F}
# Usando a função help
help(ls)

# Usando interrogação
?ls
```

Acredito que esta introdução seja suficiente para iniciarem na linguagem R. Apesar de possuir um grande número de funções nativas, o principal atrativo desta ferramenta (como o de muitas outras também), são os pacotes criados pela comunidade que ficam disponíveis para serem usados. Este será o foco do próximo tópico.

#### **Materiais de Apoio**

* [R for Beginners](https://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf)

* [Hands-On Programming with R](https://rstudio-education.github.io/hopr/)

## **Principais Pacotes Usados em Pesquisas**

Ao executar projetos de análise de daods, provavelmente você precisará utilizar soluções que não estão disponíveis no **base R** (funções nativas da ferramenta). Neste caso, você precisará de pacotes que tenham esta solução. Os pacotes do R podem ficar armazenados no [cran](https://cran.r-project.org/web/packages/available_packages_by_name.html), que significa *Comprehensie R Archive Network*, ou no github do autor do pacote.

A instalação de pacotes é bem simples, basta escrever **install.packages("nome do pacote")** e rodar. Para ver onde seus pacotes estão sendo armazenados, basta ler o output da instalação ou também através do comando:

```{r}
.libPaths()
```

Caso queira ver sua lista de pacotes, basta usar o comando:

```{r, eval=F}
installed.packages()
```

Se caso você tenha um pacote, porém ele esteja desatializado, o comando **packageVersion** lhe mostrará a versão do pacote e o comando **update.packages** irá atualizar a versão dele.

```{r, eval=F}
packageVersion("ggplot2")

update.packages("ggplot2")
```

Após instalar o pacote ou atualizá-lo, é necessário chamar este pacote para sua sessão do R, pois a instalação só faz ele ser inserido naquela pasta indicada em **.libPaths()**. Trazer o pacote para sua sessão é simples, basta usar o comando **library()** e o nome do pacote, desta vez, não precisa das aspas.

```{r, eval=F}
# Trazendo o pacote ggplot2 para meu ambiente
library(ggplot2)
```

Este método funciona para pacotes já hospedados no Cran. Caso o pacote necessário esteja no github, é necessário instalar o pacote **devtools** que conterá a função **install_github()**, que permitirá instalar pacotes do github. Em geral, recomenda-se usar pacotes do Cran, pois é semelhante a um selo de qualidade do pacote, onde o mesmo não irá conflitar com outros pacotes existentes e também conterá a documentação necessária para que a comunidade possa usá-lo.

Ao entender sobre a inclusão de pacotes, podemos listar para um projeto de pesquisa ou análise de dados, os principais pacotes que são usados. A tabela abaixo contêm os mais usados e a descrição do que cada um faz.

|Package             |          Description                     |
|--------------------|------------------------------------------|
|tidyverse           |contém vários outros pacotes para análise de dados (ex. ggplot2, dplyr, scales, entre outros) |
|rJava               |usado para fazer a conexão com o DW |
|RJDBC               |usado para fazer a conexão com o DW |
|zoo                 |usado para cálculo de médias móveis |
|patchwork           |usado para combinar gráficos        |


Veja que são poucos pacotes usados e considerando que há mais ou menos 15 mil pacotes disponíveis no Cran, pode-se afirmar que há um pareto neste cenário, pois 80% dos projetos usam 20% das *features* disponíveis. E isso é bom, pois mostra que fazer análise de dados é algo que não precisa exigir tecnologia avançada e ferramentas complexas. Veja abaixo uma imagem com os principais pacotes usados pela comunidade.

![](C:/Users/francisco.piccolo/Desktop/R/01.DFT Research/r_training/images/r_packages.PNG)

#### **Materiais de Apoio**

[R packages](http://r-pkgs.had.co.nz/)

[Tidyverse.org](https://www.tidyverse.org/)

## **Entendendo Documentos Rmarkdown**

Ao fazer análise de dados ou relatórios, muitas vezes optamos pelo excel ou por apresentações em ppt, ou até mesmo um e-mail resumindo os *insights*. Não há problema com estas alternativas, porém quando está se desenvolvendo algo mais complexo, onde serão usados gráficos, tabelas e também partes escritas indicando hipóteses, premissas e (o mais importante) conclusões, um documento Rmarkdown ou Jupyter Notebook são alternativas interessantes.

No R, para se criar um documento Rmarkdown, basta criar um documento novo usando **Ctrl + Shift + N** e na hora de salvá-lo, basta colocar o formato como **.Rmd**. Para executar este documento, pressione **Ctrl + SHift + K** (antes escreva alguma coisa). Veja que o R irá gerar um output na página **Viewer** do Rstudio.

![Output do R](C:/Users/francisco.piccolo/Desktop/R/01.DFT Research/r_training/images/teste_markdown.PNG)

O Markdown foi criado para gerar outputs em HTML e para criar um documento HTML, basta inserir esta informação no YAML do seu documento. O YAML (*yet another markup language*) é a primeira parte do documento, veja na figura abaixo o YAML deste treinamento.

![YAML](C:/Users/francisco.piccolo/Desktop/R/01.DFT Research/r_training/images/yaml.PNG)

Note que eu indiquei no formato de output o HTML document e em seguida outros aspectos, que explicarei com mais detalhes.

No seu documento criado recentemente, adicione um **YAML** com os seguintes parâmetros:

* title: "Dafiti"
* author: "Me"
* date: "2020-05-29"
* output: html_document

Veja como o documento já mudou e veja que foi gerado um arquivo .HTML na mesma pasta onde você criou seu documento .Rmd. Eu prefiro indicar para o Rstudio gerar o output do meu Rmarkdown no próprio Rstudio, na aba Viewer. Isso pode ser feito através da opção Tools (penúltima opção da Guia), Global Options, R Markdown e na opção *Show output preview in:* indicar **Viewer Pane**.

![Viewer](C:/Users/francisco.piccolo/Desktop/R/01.DFT Research/r_training/images/viewer.PNG)

Agora que temos nosso documento HTML sendo gerado, podemos escrever alguns códigos em R e testar algumas opções nestes *code chunks*. Para abrir um *code chunck* no Rmarkdown, use a tecla de atalho **Ctrl + Alt + i**. Nele, você pode inserir vários parâmetros, que serão avaliados na hora de renderizar (criar o documento HTML) o seu Rmarkdown. Os principais são explicados abaixo:

* eval (T ou F): executa ou não o código

* include (T ou F): inclui ou não o output do código

* warning (T ou F): apresenta ou não a mensagem de aviso do código

* error (T ou F): apresenta ou não a mensagem de erro do código

* echo (T ou F): apresenta ou não o código

* fig.align (center, left ou right): alinha o output do código

* fig.width e fig.height: altera a largura e altura do output do código

No seu documento Rmarkdown, crie alguns *code chunks* e teste estes parâmetros. Veja que você pode alterar a linguagem usada no *code chunk* e o HTML irá utilizar uma **syntax highlight** específica para a linguagem indicada. Veja abaixo um exemplo de código SQL:

```{sql, eval = F}
SELECT * FROM integration_layer.int_sale_item as s
```

Entendendo a formatação **YAML** e utilização de *code chunks*, você estará pronto para desenvolver pesquisas de uma forma facilmente reproduzível e versátil. Caso você não goste do formato padrão do HTML gerado pelo R, você pode utilizar outros temas presentes em pacotes do R, que irão conter um arquivo .css que será usado por último, antes do documento ser renderizado no *Viewer* do Rstudio.

Eu prefiro usar um layout específico e simples, que combina com a [página](https://sites.google.com/dafiti.com.br/dafitiwiki/dft-research?authuser=0) da Dafiti que recebe minhas pesquisas. Para usar um css específico, basta indicar no **YAML**, no parâmetro css e inserir o nome do arquivo .css que contém o layout. Abaixo há o código css do meu layout:

```{css, eval = F}
/* Whole document: */
body{
  font-family: 'Lato', sans-serif;
  font-weight: 500;
  font-size: 16px;
}

/* Headers */
h1{
	font-family: 'Lato', sans-serif;
	font-size: 40;
}
h2{
	font-family: 'Lato', sans-serif;
	font-size: 30;
}
h3{
	font-family: 'Lato', sans-serif;
	font-size: 25;
}
h4{
	font-family: 'Lato', sans-serif;
	font-size: 10;
}
```


#### **Materiais de Apoio**

* [How R helps Airbnb make the most of its data](https://peerj.com/preprints/3182/)

* [Scaling Knowledge at Airbnb](https://medium.com/airbnb-engineering/scaling-knowledge-at-airbnb-875d73eff091)

* [R Markdown Reference Guide](https://rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf)

* [R Markdown: The Definitive Guide](https://bookdown.org/yihui/rmarkdown/)

## **Conectando o R ao Redshift**

Neste tópico, vamos utilizar nosso documento Rmarkdown e alguns pacotes do R para fazer a conexão com o Redshift e extrair data.frames para serem usados nas pesquisas. 

Para se conectar ao Redshift, é preciso ter o arquivo .jar com o Driver JDBC da Amazon. Este arquivo pode ser baixado neste [link](https://docs.aws.amazon.com/pt_br/redshift/latest/mgmt/configure-jdbc-connection.html#obtain-jdbc-url). Após baixar este arquivo, crie um **code chunk** para instalar e chamar os seguintes pacotes: **rJava** e **RJDBC**.

```{r, eval = F}
install.packages("rJava")
install.packages("RJDBC")

library(rJava)
library(RJDBC)
```

Crie uma variável (i.e. driver) contendo o arquivo .jar baixado. Use o seguinte **code chunk** para isso:

```{r, eval = F}
# Veja que eu indico o pacote que possui a função JDBC. Isso é interessante, pois permite que outras pessoas, ao lerem meu código, saibam quais pacotes são necessários
driver <- RJDBC::JDBC(driverClass = "com.amazon.redshift.jdbc41.Driver", 
               classPath = Sys.glob("file_path/file.jar"), 
               identifier.quote="`")
```

Crie uma variável (i.e. db_connection) para indicar as informações do DW que será conectado pelo R. Use o seguinte **code chunk** para isso:

```{r, eval = F}
db_connection <- sprintf("jdbc:redshift://%s:%s/%s?tcpKeepAlive=true&ssl=true&sslfactory=com.amazon.redshift.ssl.NonValidatingFactory", 
                         "host of the database", 
                         "port", 
                         "database name")
```

Crie uma variável (i.e. access) que conterá as informações do DW e também as suas credenciais para acessar o DW. Use o seguinte **code chunk** para isso:

```{r, eval = F}
access <- RJDBC::dbConnect(driver, db_connection, "user", "password")
```

Agora com a conexão ao DW realizada, podemos fazer um teste simples para ver se é possível extrair dados do banco. Para isso, use a função **RJDBC::dbGetQuery()** que solicita os valores da variável **access**. Para realizar este exemplo, irei pegar as variáveis de acesso ao banco que eu armazeno em um arquivo .txt (por questões de segurança), desta forma, não é necessário escrever no Rmarkdown suas credenciais de acesso.

```{r}
library(rJava)
library(RJDBC)
```

```{r}
# Trazendo o arquivo com informações de acesso
dw_inf <- data.frame(read.table("C:/Users/francisco.piccolo/Desktop/R/Redshift_access/dw_prod_access.txt",sep=" "))
sprintf <- as.character(dw_inf[2,2])
host <- as.character(dw_inf[3,2])
port <- as.character(dw_inf[4,2])
dw <- as.character(dw_inf[5,2])
user <- as.character(dw_inf[6,2])
password <- as.character(dw_inf[7,2])

driver <- JDBC(driverClass = 'com.amazon.redshift.jdbc41.Driver', classPath = Sys.glob("C:/Users/francisco.piccolo/Documents/R/Redshift_JDBC/RedshiftJDBC41-1.1.9.1009.jar"), identifier.quote="`")
db_connection <- sprintf(sprintf, host, port, dw)
access <- dbConnect(driver, db_connection, user, password)
```

```{r}
RJDBC::dbGetQuery(access, "select sale_order_store_date::date, src_fk_sale_order_store from integration_layer.int_sale_item as s limit 10")
```

Este é um procedimento prático de trazer data.frames para o R, porém lembre-se de que o R opera com utilização da memória RAM, por isso não dá para trazer resultados de queries muito grandes, pois não vai caber na memória. Desta forma, é preciso realizar a maior parte da manipulação dos dados no SQL e apenas o resultado final para o R. Outro ponto que vale a pena ser lembrado é que o R não conseguirar ler uma query de uma tabela temporária, criada no *dBeaver* ~~(se tem aviso é por que já tentaram)~~. 

Sabendo que a maior parte da manipuçalação será no SQL, fica complicado fazer toda esta operação dentro do R. Pensando nisso, surgiu uma solução interessante, onde o código SQL é armazenado em um arquivo .sql e o R faz a leitura deste arquivo e usa-o como entrada da função **dbgetQuery()** vista anteriormente.

Vamos usar um exemplo para ficar mais claro. Crie um arquivo com um código sql e salve-o como .sql. Em seguida, usando o pacote **readr**, leia o arquivo .sql criado e salve o resultado em uma variável. Por exemplo:

```{r}
library(readr)

sql_script <- readr::read_file(file = "C:/Users/francisco.piccolo/Desktop/R/01.DFT Research/r_training/queries.sql")
```

Veja que eu salvei meu script sql na variável sql_script.

```{r}
sql_script
```

Agora, ao invés de precisar escrever no Rstudio o código SQL, eu posso usar esta variável. Desta forma, a função **dbGetQuery()** fica:

```{r, eval = F}
RJDBC::dbGetQuery(access, sql_script)
```

Com isso, eu posso escrever queries mais complexas no meu arquivo e a função irá executá-la normalmente. Agora, imagine um cenário em que você está desenvolvendo uma pesquisa e precisa executar várias queries diferentes. Seria trabalhoso criar diversos arquivos .sql diferentes para cada uma, por isso, uma alternativa que eu tenho adotado é a utilização de operações **regexp** em um arquivo .sql com várias queries, onde o **regexp** separa as queries e as salva em variáveis diferentes. Vamos testar essa solução com um exemplo:

No arquivo usado anteriormente, adicione uma nova query. Para que esta solução funcione, é necessário separar cada query por um texto que indique o começo e fim desta query. Desta forma, seu arquivo .sql ficará:

```{sql, eval = F}
-- query_1_begin
SELECT
	  fk_company
	, first_name
	, last_name
	, billet_unpaid_rate
	, avg_days_btw_billet_generation
	, total_billets_unpaid
	, total_billet_unpaid_gtv
FROM business_layer.dim_customer as d 
WHERE 1 = 1
AND fk_company = 1 
AND first_name = 'Francisco'
AND last_name = 'Piccolo'
LIMIT 10
;
-- query_1_end

-- query_2_begin
SELECT 
	  sale_order_store_date::date
	, gtv
	, avg(gtv) over (partition by 1 order by sale_order_store_date rows between 5 preceding and 0 following) as avg_gtv
FROM (
	SELECT
		  s.sale_order_store_date::date
		, sum(gtv) as gtv
	FROM integration_layer.int_sale_item as s 
	WHERE 1 = 1
	AND s.fk_company = 1
	AND s.sale_order_store_date::date >= dateadd(DAY, -90, sysdate)
	)
;
-- query_2_end
```

Com estes "separadores", eu posso criar um **regexp** para pegar apenas o script específico que eu preciso. Desta forma eu consigo "fatiar" meu arquivo .sql em diversas queries. Para fazer esta etapa, instale e chame o pacote **stringr** e teste de acordo com o exemplo abaixo no seu documento Rmarkdown.

```{r}
# Script SQL com 2 queries
sql_script
```

```{r}
library(stringr)

# Executando a segunda query do arquivo
RJDBC::dbGetQuery(access,
                  substr(sql_script,
                         min(stringr::str_locate(string = sql_script, "-- query_2_begin")),
                         max(stringr::str_locate(string = sql_script, "-- query_2_end"))))
```

Dica, o parâmetro **df_print: paged** do YAML faz com que a tabela possa ser "paginada". 

Agora podemos realizar diversas consultas ao DW e trazer os resultados para o Rstudio para realizar as análises. Isso é quase tudo o que você precisará para executar seus projetos e pesquisas. O último ponto que falta é o armazenamento do output do SQL em um arquivo compactado, de forma que você não precise fazer a consulta ao DW toda vez que quiser **renderizar** seu documento. O "renderizar" é quando se executa seu Rmarkdown através do **Ctrl + Shift + K**. 

Imagine que você faça uma alteração simples em um gráfico ou corrija uma palavra e precise renderizar seu documento, porém você executa queries um pouco pesadas. Isso iria criar um gargalo e afetaria a produtividade do seu trabalho. 

Para solucionar isso, atualmente eu adoto uma metodologia que funciona da seguinte forma. Ao criar uma variável com o output da minha query, por exemplo **query_1**, eu salvo este output em uma pasta (recomendo ser na mesma pasta em que estou realizando a pesquisa). Logo abaixo deste código que salva o output, eu faço um novo código que irá ler este arquivo e é este código que irá rodar toda vez que eu renderizar meu documento Rmarkdown. 

Para facilitar o entendimento, vamos ver um exemplo:

```{r, eval = F}
# Criando uma variável contendo o output de uma query
query_1 <- RJDBC::dbGetQuery(access,
                  substr(sql_script,
                         min(stringr::str_locate(string = sql_script, "-- query_2_begin")),
                         max(stringr::str_locate(string = sql_script, "-- query_2_end"))))
```

Agora vou criar o arquivo .RDS (arquivo que é lido pelo R). No **code chunk** desta etapa e da anterior, eu indico **eval = F**, ou seja, o código não será executado na renderização do documento.

```{r, eval = F}
# Usando a função write_rds para gravar o output do SQL em uma pasta
readr::write_rds(query_1, "C:/Users/francisco.piccolo/Desktop/R/01.DFT Research/r_training/datasets/query_1.RDS")
```

Por fim, em um novo **code chunk**, eu insiro a função read_rds e salvo o resultado na mesma variável **query_1** criada anteriormente.

```{r}
# Salvando o resultado em uma variável
readr::read_rds("C:/Users/francisco.piccolo/Desktop/R/01.DFT Research/r_training/datasets/query_1.RDS") -> query_1
```

Veja que eu atribuo o resultado a uma variável usando o **->**. É uma alternativa para se criar variáveis.

Com isso, eu preciso apenas rodar o SQL durante o desenvolvimento do estudo, na parte mais inicial do projeto. No final do projeto, o foco é mais em ajustes de detalhes, não precisando rodar novamente toda a query.

Caso seu estudo precise rodar com frequência, para pegar dados recentes, a alternativa não será interessante, pois será necessário rodar o código SQL a cada renderização do documento.

#### **Materiais de Apoio**

[Connecting to Amazon Redshift from R via JDBC Driver](https://www.progress.com/tutorials/jdbc/connecting-to-amazon-redshift-from-r-via-jdbc-driver)

[A comprehensive guide to connect R to Amazon Redshift](https://www.r-bloggers.com/a-comprehensive-guide-to-connect-r-to-amazon-redshift/)

## **Desenvolvendo Pesquias** {.tabset .tabset-fade .tabset-pills}

Entendendo os métodos de criação de documentos Rmarkdown, conexão ao DW e geração de arquivos RDS para salvar os resultados da consulta ao DW, podemos seguir para a parte que cria valor para o negócio, o desenvolvimento de pesquisas. 

Desenvolver pesquisas no R fica bem simples com a utilização do Rmarkdown. Os componentes básicos de uma pesquisa são:

1. Hipótese

2. Premissas

3. Análise de Dados

4. Conclusão

Este tópico, irá focar no item 3, onde iremos utilizar alguns dados do DW para gerar visualizações e chegarmos em conclusões e *insights* sobre o negócio. Para fazer esta atividade, vamos usar o pacote **tidyverse** que contêm vários outros pacotes usados em análise de dados.

Antes de iniciar a programar, vamos refletir um pouco sobre o desenvolvimento de pesquisa. Quando eu vou desenvolver uma pesquisa, busco abordar um tópico bem específico e esta especificação eu faço através de uma **pergunta**, que será o ponto de partida para formulação da minha hipótese. Veja alguns exemplos de pesquisas realizadas recentemente:

* [Slipers Impact on Cancelation Rate](https://sites.google.com/dafiti.com.br/dafitiwiki/dft-research/2019-11-01-slipers-impact-on-cancel-rate?authuser=0)

* [Channel Impact on Cancel Rate](https://sites.google.com/dafiti.com.br/dafitiwiki/dft-research/2020-05-21-channel-impact-on-cancel-rate?authuser=0)

* [Answer Rate Analysis for Success Page Survey](https://sites.google.com/dafiti.com.br/dafitiwiki/dft-research/2020-04-27-nps-success-page-answer-rate-analysis?authuser=0)

Note que o título e o subtítulo já indicam algo bem específico que será estudado. Com isso, você consegue aprofundar o tema, sem se perder na geração de conclusões. Esta é uma prática que eu venho adotando e tem funcionado. 

Pode ocorrer de você desenvolver uma pesquisa e perceber que seu tópico ou sua pergunta está muito aberta. Neste caso, eu sugeriria você subdividir sua análise e fazer pesquias separadas para cada subtópico. Outra situação que pode ocorrer, é o *stakeholder* da sua pesquisa fazer a leitura dela e sugerir novas análises. Neste caso, talvez seja interessante fazer estas análises em outra pesquisa, ao invés de aumentar a pesquisa que ele leu.

Bom, acredito que com estas considerações podemos iniciar no desenvolvimento de algumas análises. Vamos ver se conseguimos gerar alguns insights de temas aleatórios da Dafiti. Cada pesquisa será feita em abas diferentes deste HTML, isto é feito com o uso dos parâmetros **{.tabset .tabset-fade .tabset-pills}** junto do seu header ("#") no Markdown.

### **Pesquisa 1**

### **2**

### **3**

### **4**

#### **Materiais de Apoio**

* [A Layered Grammar of Graphics](https://byrneslab.net/classes/biol607/readings/wickham_layered-grammar.pdf)

* [R for Data Science](https://r4ds.had.co.nz/)

* [Exploratory Data Analysis with R](https://bookdown.org/rdpeng/exdata/)

## **Inserindo Pesquisas na Página da Dafiti**








